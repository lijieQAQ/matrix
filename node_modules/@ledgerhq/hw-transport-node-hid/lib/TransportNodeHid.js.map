{"version":3,"sources":["../src/TransportNodeHid.js"],"names":["listenDevicesDebounce","listenDevicesPollingSkip","TransportNodeHid","path","Promise","resolve","HID","device","isSupported","list","setListenDevicesDebounce","delay","setListenDevicesPollingSkip","conditionToSkip","setListenDevicesDebug","console","warn","listen","observer","unsubscribed","then","devices","descriptor","deviceModel","productId","next","type","events","stop","onAdd","onRemove","on","unsubscribe","removeListener"],"mappings":"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","file":"TransportNodeHid.js","sourcesContent":["//@flow\n\nimport HID from \"node-hid\";\nimport TransportNodeHidNoEvents, {\n  getDevices\n} from \"@ledgerhq/hw-transport-node-hid-noevents\";\nimport type {\n  Observer,\n  DescriptorEvent,\n  Subscription\n} from \"@ledgerhq/hw-transport\";\nimport { identifyUSBProductId } from \"@ledgerhq/devices\";\nimport { TransportError } from \"@ledgerhq/errors\";\nimport listenDevices from \"./listenDevices\";\n\nlet listenDevicesDebounce = 500;\nlet listenDevicesPollingSkip = () => false;\n\n/**\n * node-hid Transport implementation\n * @example\n * import TransportNodeHid from \"@ledgerhq/hw-transport-node-hid\";\n * ...\n * TransportNodeHid.create().then(transport => ...)\n */\nexport default class TransportNodeHid extends TransportNodeHidNoEvents {\n  /**\n   *\n   */\n  static isSupported = TransportNodeHidNoEvents.isSupported;\n\n  /**\n   *\n   */\n  static list = TransportNodeHidNoEvents.list;\n\n  /**\n   *\n   */\n  static setListenDevicesDebounce = (delay: number) => {\n    listenDevicesDebounce = delay;\n  };\n\n  /**\n   *\n   */\n  static setListenDevicesPollingSkip = (conditionToSkip: () => boolean) => {\n    listenDevicesPollingSkip = conditionToSkip;\n  };\n\n  /**\n   *\n   */\n  static setListenDevicesDebug = () => {\n    console.warn(\n      \"setListenDevicesDebug is deprecated. Use @ledgerhq/logs instead. No logs will get emitted there anymore.\"\n    );\n  };\n\n  /**\n   */\n  static listen = (\n    observer: Observer<DescriptorEvent<?string>>\n  ): Subscription => {\n    let unsubscribed = false;\n    Promise.resolve(getDevices()).then(devices => {\n      // this needs to run asynchronously so the subscription is defined during this phase\n      for (const device of devices) {\n        if (!unsubscribed) {\n          const descriptor: string = device.path;\n          const deviceModel = identifyUSBProductId(device.productId);\n          observer.next({ type: \"add\", descriptor, device, deviceModel });\n        }\n      }\n    });\n    const { events, stop } = listenDevices(\n      listenDevicesDebounce,\n      listenDevicesPollingSkip\n    );\n\n    const onAdd = device => {\n      if (unsubscribed || !device) return;\n      const deviceModel = identifyUSBProductId(device.productId);\n      observer.next({\n        type: \"add\",\n        descriptor: device.path,\n        deviceModel,\n        device\n      });\n    };\n    const onRemove = device => {\n      if (unsubscribed || !device) return;\n      const deviceModel = identifyUSBProductId(device.productId);\n      observer.next({\n        type: \"remove\",\n        descriptor: device.path,\n        deviceModel,\n        device\n      });\n    };\n    events.on(\"add\", onAdd);\n    events.on(\"remove\", onRemove);\n    function unsubscribe() {\n      unsubscribed = true;\n      events.removeListener(\"add\", onAdd);\n      events.removeListener(\"remove\", onRemove);\n      stop();\n    }\n    return { unsubscribe };\n  };\n\n  /**\n   * if path=\"\" is not provided, the library will take the first device\n   */\n  static open(path: ?string) {\n    if (path) {\n      return Promise.resolve(new TransportNodeHid(new HID.HID(path)));\n    }\n    const device = getDevices()[0];\n    if (!device) throw new TransportError(\"NoDevice\", \"NoDevice\");\n    return Promise.resolve(new TransportNodeHid(new HID.HID(device.path)));\n  }\n}\n"]}